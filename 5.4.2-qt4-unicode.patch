Cumulative result of:

fedora/qt5-qtwebkit-dont-depend-on-icu.patch
fedora/revert-qt4-unicode-removal.patch (-R)
fedora/webkit-commit-151422.patch (-R)

--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WTF/WTF.pro	2015-05-29 15:30:56.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WTF/WTF.pro	2015-07-13 16:55:21.293537700 -0500
@@ -170,6 +170,7 @@ HEADERS += \
     unicode/CharacterNames.h \
     unicode/Collator.h \
     unicode/icu/UnicodeIcu.h \
+    unicode/qt4/UnicodeQt4.h \
     unicode/ScriptCodesFromICU.h \
     unicode/Unicode.h \
     unicode/UnicodeMacrosFromICU.h \
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WTF/wtf/Platform.h	2015-05-29 15:30:56.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WTF/wtf/Platform.h	2015-07-13 16:55:10.606180600 -0500
@@ -580,9 +580,13 @@
 # define WTF_USE_WCHAR_UNICODE 1
 #endif
 
+#if OS(WINDOWS) && PLATFORM(QT)
+#define WTF_USE_QT4_UNICODE 1
+#else
 #if !USE(WCHAR_UNICODE)
 #define WTF_USE_ICU_UNICODE 1
 #endif
+#endif
 
 #if PLATFORM(MAC) && !PLATFORM(IOS)
 #if CPU(X86_64)
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WTF/wtf/unicode/Unicode.h	2015-05-29 15:30:56.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WTF/wtf/unicode/Unicode.h	2015-07-13 16:55:21.296038000 -0500
@@ -30,6 +30,8 @@ typedef unsigned char LChar;
 
 #if USE(ICU_UNICODE)
 #include <wtf/unicode/icu/UnicodeIcu.h>
+#elif USE(QT4_UNICODE)
+#include "qt4/UnicodeQt4.h"
 #elif USE(WCHAR_UNICODE)
 #include <wtf/unicode/wchar/UnicodeWchar.h>
 #else
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WTF/wtf/unicode/qt4/UnicodeQt4.h	1969-12-31 18:00:00.000000000 -0600
+++ src/qtwebkit-opensource-src-5.4.2/Source/WTF/wtf/unicode/qt4/UnicodeQt4.h	2015-07-13 16:55:21.303539000 -0500
@@ -0,0 +1,377 @@
+/*
+ *  Copyright (C) 2006 George Staikos <staikos@kde.org>
+ *  Copyright (C) 2006 Alexey Proskuryakov <ap@nypop.com>
+ *  Copyright (C) 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifndef WTF_UNICODE_QT4_H
+#define WTF_UNICODE_QT4_H
+
+#include <wtf/unicode/ScriptCodesFromICU.h>
+#include <wtf/unicode/UnicodeMacrosFromICU.h>
+
+#include <QChar>
+#include <QString>
+
+#include <config.h>
+
+#include <stdint.h>
+#if USE(ICU_UNICODE)
+#include <unicode/ubrk.h>
+#endif
+
+QT_BEGIN_NAMESPACE
+namespace QUnicodeTables {
+    struct Properties {
+        ushort category : 8;
+        ushort line_break_class : 8;
+        ushort direction : 8;
+        ushort combiningClass :8;
+        ushort joining : 2;
+        signed short digitValue : 6; /* 5 needed */
+        ushort unicodeVersion : 4;
+        ushort lowerCaseSpecial : 1;
+        ushort upperCaseSpecial : 1;
+        ushort titleCaseSpecial : 1;
+        ushort caseFoldSpecial : 1; /* currently unused */
+        signed short mirrorDiff : 16;
+        signed short lowerCaseDiff : 16;
+        signed short upperCaseDiff : 16;
+        signed short titleCaseDiff : 16;
+        signed short caseFoldDiff : 16;
+    };
+    Q_CORE_EXPORT const Properties * QT_FASTCALL properties(uint ucs4);
+    Q_CORE_EXPORT const Properties * QT_FASTCALL properties(ushort ucs2);
+}
+QT_END_NAMESPACE
+
+// ugly hack to make UChar compatible with JSChar in API/JSStringRef.h
+#if defined(Q_OS_WIN) || (COMPILER(RVCT) && !OS(LINUX))
+typedef wchar_t UChar;
+#else
+typedef uint16_t UChar;
+#endif
+
+#if !USE(ICU_UNICODE)
+typedef uint32_t UChar32;
+#endif
+
+namespace WTF {
+namespace Unicode {
+
+enum Direction {
+    LeftToRight = QChar::DirL,
+    RightToLeft = QChar::DirR,
+    EuropeanNumber = QChar::DirEN,
+    EuropeanNumberSeparator = QChar::DirES,
+    EuropeanNumberTerminator = QChar::DirET,
+    ArabicNumber = QChar::DirAN,
+    CommonNumberSeparator = QChar::DirCS,
+    BlockSeparator = QChar::DirB,
+    SegmentSeparator = QChar::DirS,
+    WhiteSpaceNeutral = QChar::DirWS,
+    OtherNeutral = QChar::DirON,
+    LeftToRightEmbedding = QChar::DirLRE,
+    LeftToRightOverride = QChar::DirLRO,
+    RightToLeftArabic = QChar::DirAL,
+    RightToLeftEmbedding = QChar::DirRLE,
+    RightToLeftOverride = QChar::DirRLO,
+    PopDirectionalFormat = QChar::DirPDF,
+    NonSpacingMark = QChar::DirNSM,
+    BoundaryNeutral = QChar::DirBN
+};
+
+enum DecompositionType {
+    DecompositionNone = QChar::NoDecomposition,
+    DecompositionCanonical = QChar::Canonical,
+    DecompositionCompat = QChar::Compat,
+    DecompositionCircle = QChar::Circle,
+    DecompositionFinal = QChar::Final,
+    DecompositionFont = QChar::Font,
+    DecompositionFraction = QChar::Fraction,
+    DecompositionInitial = QChar::Initial,
+    DecompositionIsolated = QChar::Isolated,
+    DecompositionMedial = QChar::Medial,
+    DecompositionNarrow = QChar::Narrow,
+    DecompositionNoBreak = QChar::NoBreak,
+    DecompositionSmall = QChar::Small,
+    DecompositionSquare = QChar::Square,
+    DecompositionSub = QChar::Sub,
+    DecompositionSuper = QChar::Super,
+    DecompositionVertical = QChar::Vertical,
+    DecompositionWide = QChar::Wide
+};
+
+enum CharCategory {
+    NoCategory = 0,
+    Mark_NonSpacing = U_MASK(QChar::Mark_NonSpacing),
+    Mark_SpacingCombining = U_MASK(QChar::Mark_SpacingCombining),
+    Mark_Enclosing = U_MASK(QChar::Mark_Enclosing),
+    Number_DecimalDigit = U_MASK(QChar::Number_DecimalDigit),
+    Number_Letter = U_MASK(QChar::Number_Letter),
+    Number_Other = U_MASK(QChar::Number_Other),
+    Separator_Space = U_MASK(QChar::Separator_Space),
+    Separator_Line = U_MASK(QChar::Separator_Line),
+    Separator_Paragraph = U_MASK(QChar::Separator_Paragraph),
+    Other_Control = U_MASK(QChar::Other_Control),
+    Other_Format = U_MASK(QChar::Other_Format),
+    Other_Surrogate = U_MASK(QChar::Other_Surrogate),
+    Other_PrivateUse = U_MASK(QChar::Other_PrivateUse),
+    Other_NotAssigned = U_MASK(QChar::Other_NotAssigned),
+    Letter_Uppercase = U_MASK(QChar::Letter_Uppercase),
+    Letter_Lowercase = U_MASK(QChar::Letter_Lowercase),
+    Letter_Titlecase = U_MASK(QChar::Letter_Titlecase),
+    Letter_Modifier = U_MASK(QChar::Letter_Modifier),
+    Letter_Other = U_MASK(QChar::Letter_Other),
+    Punctuation_Connector = U_MASK(QChar::Punctuation_Connector),
+    Punctuation_Dash = U_MASK(QChar::Punctuation_Dash),
+    Punctuation_Open = U_MASK(QChar::Punctuation_Open),
+    Punctuation_Close = U_MASK(QChar::Punctuation_Close),
+    Punctuation_InitialQuote = U_MASK(QChar::Punctuation_InitialQuote),
+    Punctuation_FinalQuote = U_MASK(QChar::Punctuation_FinalQuote),
+    Punctuation_Other = U_MASK(QChar::Punctuation_Other),
+    Symbol_Math = U_MASK(QChar::Symbol_Math),
+    Symbol_Currency = U_MASK(QChar::Symbol_Currency),
+    Symbol_Modifier = U_MASK(QChar::Symbol_Modifier),
+    Symbol_Other = U_MASK(QChar::Symbol_Other)
+};
+
+
+// FIXME: handle surrogates correctly in all methods
+
+inline UChar32 toLower(UChar32 ch)
+{
+    return QChar::toLower(uint32_t(ch));
+}
+
+inline int toLower(UChar* result, int resultLength, const UChar* src, int srcLength,  bool* error)
+{
+    const UChar *e = src + srcLength;
+    const UChar *s = src;
+    UChar *r = result;
+    uint rindex = 0;
+
+    // this avoids one out of bounds check in the loop
+    if (s < e && QChar(*s).isLowSurrogate()) {
+        if (r)
+            r[rindex] = *s++;
+        ++rindex;
+    }
+
+    int needed = 0;
+    while (s < e && (rindex < uint(resultLength) || !r)) {
+        uint c = *s;
+        if (QChar(c).isLowSurrogate() && QChar(*(s - 1)).isHighSurrogate())
+            c = QChar::surrogateToUcs4(*(s - 1), c);
+        const QUnicodeTables::Properties *prop = QUnicodeTables::properties(c);
+        if (prop->lowerCaseSpecial) {
+            QString qstring;
+            if (c < 0x10000) {
+                qstring += QChar(c);
+            } else {
+                qstring += QChar(*(s-1));
+                qstring += QChar(*s);
+            }
+            qstring = qstring.toLower();
+            for (int i = 0; i < qstring.length(); ++i) {
+                if (rindex >= uint(resultLength)) {
+                    needed += qstring.length() - i;
+                    break;
+                }
+                if (r)
+                    r[rindex] = qstring.at(i).unicode();
+                ++rindex;
+            }
+        } else {
+            if (r)
+                r[rindex] = *s + prop->lowerCaseDiff;
+            ++rindex;
+        }
+        ++s;
+    }
+    if (s < e)
+        needed += e - s;
+    *error = (needed != 0);
+    if (rindex < uint(resultLength))
+        r[rindex] = 0;
+    return rindex + needed;
+}
+
+inline UChar32 toUpper(UChar32 c)
+{
+    return QChar::toUpper(uint32_t(c));
+}
+
+inline int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength,  bool* error)
+{
+    const UChar *e = src + srcLength;
+    const UChar *s = src;
+    UChar *r = result;
+    int rindex = 0;
+
+    // this avoids one out of bounds check in the loop
+    if (s < e && QChar(*s).isLowSurrogate()) {
+        if (r)
+            r[rindex] = *s++;
+        ++rindex;
+    }
+
+    int needed = 0;
+    while (s < e && (rindex < resultLength || !r)) {
+        uint c = *s;
+        if (QChar(c).isLowSurrogate() && QChar(*(s - 1)).isHighSurrogate())
+            c = QChar::surrogateToUcs4(*(s - 1), c);
+        const QUnicodeTables::Properties *prop = QUnicodeTables::properties(c);
+        if (prop->upperCaseSpecial) {
+            QString qstring;
+            if (c < 0x10000) {
+                qstring += QChar(c);
+            } else {
+                qstring += QChar(*(s-1));
+                qstring += QChar(*s);
+            }
+            qstring = qstring.toUpper();
+            for (int i = 0; i < qstring.length(); ++i) {
+                if (rindex >= resultLength) {
+                    needed += qstring.length() - i;
+                    break;
+                }
+                if (r)
+                    r[rindex] = qstring.at(i).unicode();
+                ++rindex;
+            }
+        } else {
+            if (r)
+                r[rindex] = *s + prop->upperCaseDiff;
+            ++rindex;
+        }
+        ++s;
+    }
+    if (s < e)
+        needed += e - s;
+    *error = (needed != 0);
+    if (rindex < resultLength)
+        r[rindex] = 0;
+    return rindex + needed;
+}
+
+inline int toTitleCase(UChar32 c)
+{
+    return QChar::toTitleCase(uint32_t(c));
+}
+
+inline UChar32 foldCase(UChar32 c)
+{
+    return QChar::toCaseFolded(uint32_t(c));
+}
+
+inline int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength,  bool* error)
+{
+    // FIXME: handle special casing. Easiest with some low level API in Qt
+    *error = false;
+    if (resultLength < srcLength) {
+        *error = true;
+        return srcLength;
+    }
+    for (int i = 0; i < srcLength; ++i)
+        result[i] = QChar::toCaseFolded(ushort(src[i]));
+    return srcLength;
+}
+
+inline bool isArabicChar(UChar32 c)
+{
+    return c >= 0x0600 && c <= 0x06FF;
+}
+
+inline bool isPrintableChar(UChar32 c)
+{
+    const uint test = U_MASK(QChar::Other_Control) |
+                      U_MASK(QChar::Other_NotAssigned);
+    return !(U_MASK(QChar::category(uint32_t(c))) & test);
+}
+
+inline bool isSeparatorSpace(UChar32 c)
+{
+    return QChar::category(uint32_t(c)) == QChar::Separator_Space;
+}
+
+inline bool isPunct(UChar32 c)
+{
+    const uint test = U_MASK(QChar::Punctuation_Connector) |
+                      U_MASK(QChar::Punctuation_Dash) |
+                      U_MASK(QChar::Punctuation_Open) |
+                      U_MASK(QChar::Punctuation_Close) |
+                      U_MASK(QChar::Punctuation_InitialQuote) |
+                      U_MASK(QChar::Punctuation_FinalQuote) |
+                      U_MASK(QChar::Punctuation_Other);
+    return U_MASK(QChar::category(uint32_t(c))) & test;
+}
+
+inline bool isLower(UChar32 c)
+{
+    return QChar::category(uint32_t(c)) == QChar::Letter_Lowercase;
+}
+
+inline bool hasLineBreakingPropertyComplexContext(UChar32)
+{
+    // FIXME: Implement this to return whether the character has line breaking property SA (Complex Context).
+    return false;
+}
+
+inline UChar32 mirroredChar(UChar32 c)
+{
+    return QChar::mirroredChar(uint32_t(c));
+}
+
+inline uint8_t combiningClass(UChar32 c)
+{
+    return QChar::combiningClass(uint32_t(c));
+}
+
+inline DecompositionType decompositionType(UChar32 c)
+{
+    return (DecompositionType)QChar::decompositionTag(c);
+}
+
+inline int umemcasecmp(const UChar* a, const UChar* b, int len)
+{
+    // handle surrogates correctly
+    for (int i = 0; i < len; ++i) {
+        uint c1 = QChar::toCaseFolded(ushort(a[i]));
+        uint c2 = QChar::toCaseFolded(ushort(b[i]));
+        if (c1 != c2)
+            return c1 - c2;
+    }
+    return 0;
+}
+
+inline Direction direction(UChar32 c)
+{
+    return (Direction)QChar::direction(uint32_t(c));
+}
+
+inline CharCategory category(UChar32 c)
+{
+    return (CharCategory) U_MASK(QChar::category(uint32_t(c)));
+}
+
+} // namespace Unicode
+} // namespace WTF
+
+#endif // WTF_UNICODE_QT4_H
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/Target.pri	2015-05-29 15:31:07.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/Target.pri	2015-07-13 16:55:21.314540400 -0500
@@ -2359,6 +2359,7 @@ HEADERS += \
     platform/text/DecodeEscapeSequences.h \
     platform/text/Hyphenation.h \
     platform/text/QuotedPrintable.h \
+    platform/text/qt/TextCodecQt.h \
     platform/text/RegularExpression.h \
     platform/text/SegmentedString.h \
     platform/text/TextBoundaries.h \
@@ -2947,6 +2948,7 @@ SOURCES += \
     platform/qt/TemporaryLinkStubsQt.cpp \
     platform/text/qt/TextBoundariesQt.cpp \
     platform/text/qt/TextBreakIteratorInternalICUQt.cpp \
+    platform/text/qt/TextCodecQt.cpp \
     platform/qt/WidgetQt.cpp
 
 use?(LIBXML2) {
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/KURL.cpp	2015-05-29 15:31:03.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/KURL.cpp	2015-07-13 16:55:21.325041700 -0500
@@ -40,6 +40,8 @@
 
 #if USE(ICU_UNICODE)
 #include <unicode/uidna.h>
+#elif USE(QT4_UNICODE)
+#include <QUrl>
 #endif
 
 // FIXME: This file makes too much use of the + operator on String.
@@ -1496,6 +1498,9 @@ static void appendEncodedHostname(UCharB
         hostnameBufferLength, UIDNA_ALLOW_UNASSIGNED, 0, &error);
     if (error == U_ZERO_ERROR)
         buffer.append(hostnameBuffer, numCharactersConverted);
+#elif USE(QT4_UNICODE)
+    QByteArray result = QUrl::toAce(String(str, strLen));
+    buffer.append(result.constData(), result.length());
 #endif
 }
 
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/ThreadGlobalData.cpp	2015-05-29 15:31:03.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/ThreadGlobalData.cpp	2015-07-13 16:55:10.629183500 -0500
@@ -38,6 +38,8 @@
 
 #if USE(ICU_UNICODE)
 #include "TextCodecICU.h"
+#elif USE(QT4_UNICODE)
+#include "qt/TextCodecQt.h"
 #endif
 
 #if PLATFORM(MAC)
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/graphics/SurrogatePairAwareTextIterator.cpp	2015-05-29 15:31:04.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/graphics/SurrogatePairAwareTextIterator.cpp	2015-07-13 16:55:21.328042100 -0500
@@ -90,6 +90,11 @@ UChar32 SurrogatePairAwareTextIterator::
         int32_t resultLength = unorm_normalize(m_characters, 2, UNORM_NFC, UNORM_UNICODE_3_2, &normalizedCharacters[0], 2, &uStatus);
         if (resultLength == 1 && !uStatus)
             return normalizedCharacters[0];
+#elif USE(QT4_UNICODE)
+        QString tmp(reinterpret_cast<const QChar*>(m_characters), 2);
+        QString res = tmp.normalized(QString::NormalizationForm_C, QChar::Unicode_3_2);
+        if (res.length() == 1)
+            return res.at(0).unicode();
 #endif
     }
 
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/TextAllInOne.cpp	2015-05-29 15:31:03.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/TextAllInOne.cpp	2015-07-13 16:55:10.615681800 -0500
@@ -27,7 +27,11 @@
 
 #include "TextBoundaries.cpp"
 #include "TextBreakIterator.cpp"
+#if USE(QT4_UNICODE)
+#include "TextBreakIteratorQt.cpp"
+#else
 #include "TextBreakIteratorICU.cpp"
+#endif
 #include "TextCodec.cpp"
 #include "TextCodecICU.cpp"
 #include "TextCodecLatin1.cpp"
@@ -35,6 +39,10 @@
 #include "TextCodecUTF8.cpp"
 #include "TextCodecUserDefined.cpp"
 #include "TextEncoding.cpp"
+#if USE(QT4_UNICODE)
+#include "TextEncodingDetectorNone.cpp"
+#else
 #include "TextEncodingDetectorICU.cpp"
+#endif
 #include "TextEncodingRegistry.cpp"
 #include "TextStream.cpp"
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/TextBreakIteratorQt.cpp	1969-12-31 18:00:00.000000000 -0600
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/TextBreakIteratorQt.cpp	2015-07-13 16:55:10.634684200 -0500
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2006 Lars Knoll <lars@trolltech.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "config.h"
+#include "TextBreakIterator.h"
+
+#include <QtCore/qtextboundaryfinder.h>
+#include <algorithm>
+#include <qdebug.h>
+#include <wtf/Atomics.h>
+
+// #define DEBUG_TEXT_ITERATORS
+#ifdef DEBUG_TEXT_ITERATORS
+#define DEBUG qDebug
+#else
+#define DEBUG if (1) {} else qDebug
+#endif
+
+using namespace WTF;
+using namespace std;
+
+namespace WebCore {
+
+    class TextBreakIterator : public QTextBoundaryFinder {
+    public:
+        TextBreakIterator(QTextBoundaryFinder::BoundaryType type, const QString& string)
+            : QTextBoundaryFinder(type, string)
+        { }
+        TextBreakIterator()
+            : QTextBoundaryFinder()
+        { }
+    };
+
+    TextBreakIterator* setUpIterator(TextBreakIterator& iterator, QTextBoundaryFinder::BoundaryType type, const UChar* characters, int length)
+    {
+        if (!characters || !length)
+            return 0;
+
+        if (iterator.isValid() && type == iterator.type() && iterator.string() == QString::fromRawData(reinterpret_cast<const QChar*>(characters), length)) {
+            iterator.toStart();
+            return &iterator;
+        }
+
+        iterator = TextBreakIterator(type, QString(reinterpret_cast<const QChar*>(characters), length));
+        return &iterator;
+    }
+
+    TextBreakIterator* wordBreakIterator(const UChar* string, int length)
+    {
+        static TextBreakIterator staticWordBreakIterator;
+        return setUpIterator(staticWordBreakIterator, QTextBoundaryFinder::Word, string, length);
+    }
+
+    static TextBreakIterator* nonSharedCharacterBreakIterator;
+
+    NonSharedCharacterBreakIterator::NonSharedCharacterBreakIterator(const UChar* buffer, int length)
+    {
+        m_iterator = nonSharedCharacterBreakIterator;
+        bool createdIterator = m_iterator && weakCompareAndSwap(reinterpret_cast<void**>(&nonSharedCharacterBreakIterator), m_iterator, 0);
+        if (!createdIterator)
+            m_iterator = new TextBreakIterator();
+        if (!setUpIterator(*m_iterator, QTextBoundaryFinder::Grapheme, buffer, length)) {
+            delete m_iterator;
+            m_iterator = 0;
+        }
+    }
+
+    NonSharedCharacterBreakIterator::~NonSharedCharacterBreakIterator()
+    {
+        if (!weakCompareAndSwap(reinterpret_cast<void**>(&nonSharedCharacterBreakIterator), 0, m_iterator))
+            delete m_iterator;
+    }
+
+    TextBreakIterator* cursorMovementIterator(const UChar* string, int length)
+    {
+        static TextBreakIterator staticCursorMovementIterator;
+        return setUpIterator(staticCursorMovementIterator, QTextBoundaryFinder::Grapheme, string, length);
+    }
+
+    static TextBreakIterator* staticLineBreakIterator;
+
+    TextBreakIterator* acquireLineBreakIterator(const UChar* string, int length, const AtomicString&, const UChar* priorContext, unsigned priorContextLength)
+    {
+        TextBreakIterator* lineBreakIterator = 0;
+        if (staticLineBreakIterator) {
+            setUpIterator(*staticLineBreakIterator, QTextBoundaryFinder::Line, string, length);
+            std::swap(staticLineBreakIterator, lineBreakIterator);
+        }
+
+        if (!lineBreakIterator && string && length)
+            lineBreakIterator = new TextBreakIterator(QTextBoundaryFinder::Line, QString(reinterpret_cast<const QChar*>(string), length));
+
+        return lineBreakIterator;
+    }
+
+    void releaseLineBreakIterator(TextBreakIterator* iterator)
+    {
+        ASSERT(iterator);
+
+        if (!staticLineBreakIterator)
+            staticLineBreakIterator = iterator;
+        else
+            delete iterator;
+    }
+
+    TextBreakIterator* sentenceBreakIterator(const UChar* string, int length)
+    {
+        static TextBreakIterator staticSentenceBreakIterator;
+        return setUpIterator(staticSentenceBreakIterator, QTextBoundaryFinder::Sentence, string, length);
+
+    }
+
+    int textBreakFirst(TextBreakIterator* bi)
+    {
+        bi->toStart();
+        DEBUG() << "textBreakFirst" << bi->position();
+        return bi->position();
+    }
+
+    int textBreakNext(TextBreakIterator* bi)
+    {
+        int pos = bi->toNextBoundary();
+        DEBUG() << "textBreakNext" << pos;
+        return pos;
+    }
+
+    int textBreakPreceding(TextBreakIterator* bi, int pos)
+    {
+        bi->setPosition(pos);
+        int newpos = bi->toPreviousBoundary();
+        DEBUG() << "textBreakPreceding" << pos << newpos;
+        return newpos;
+    }
+
+    int textBreakFollowing(TextBreakIterator* bi, int pos)
+    {
+        bi->setPosition(pos);
+        int newpos = bi->toNextBoundary();
+        DEBUG() << "textBreakFollowing" << pos << newpos;
+        return newpos;
+    }
+
+    int textBreakCurrent(TextBreakIterator* bi)
+    {
+        return bi->position();
+    }
+
+    bool isTextBreak(TextBreakIterator*, int)
+    {
+        return true;
+    }
+
+    bool isWordTextBreak(TextBreakIterator*)
+    {
+        return true;
+    }
+
+}
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/TextEncoding.cpp	2015-05-29 15:31:03.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/TextEncoding.cpp	2015-07-13 16:55:21.334042800 -0500
@@ -37,6 +37,8 @@
 
 #if USE(ICU_UNICODE)
 #include <unicode/unorm.h>
+#elif USE(QT4_UNICODE)
+#include <QString>
 #endif
 
 namespace WebCore {
@@ -101,6 +103,10 @@ CString TextEncoding::encode(const UChar
         sourceLength = normalizedLength;
     }
     return newTextCodec(*this)->encode(source, sourceLength, handling);
+#elif USE(QT4_UNICODE)
+    QString str(reinterpret_cast<const QChar*>(characters), length);
+    str = str.normalized(QString::NormalizationForm_C);
+    return newTextCodec(*this)->encode(reinterpret_cast<const UChar *>(str.utf16()), str.length(), handling);
 #elif OS(WINDOWS) && USE(WCHAR_UNICODE)
     // normalization will be done by Windows CE API
     OwnPtr<TextCodec> textCodec = newTextCodec(*this);
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/TextEncodingRegistry.cpp	2015-05-29 15:31:03.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/TextEncodingRegistry.cpp	2015-07-13 16:55:21.339543500 -0500
@@ -42,6 +42,9 @@
 #if USE(ICU_UNICODE)
 #include "TextCodecICU.h"
 #endif
+#if USE(QT4_UNICODE)
+#include "qt/TextCodecQt.h"
+#endif
 #if PLATFORM(MAC)
 #include "TextCodecMac.h"
 #endif
@@ -293,6 +296,11 @@ static void extendTextCodecMaps()
     TextCodecICU::registerCodecs(addToTextCodecMap);
 #endif
 
+#if USE(QT4_UNICODE)
+    TextCodecQt::registerEncodingNames(addToTextEncodingNameMap);
+    TextCodecQt::registerCodecs(addToTextCodecMap);
+#endif
+
 #if PLATFORM(MAC)
     TextCodecMac::registerEncodingNames(addToTextEncodingNameMap);
     TextCodecMac::registerCodecs(addToTextCodecMap);
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/qt/TextCodecQt.cpp	1969-12-31 18:00:00.000000000 -0600
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/qt/TextCodecQt.cpp	2015-07-13 16:55:21.348544700 -0500
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2006 Lars Knoll <lars@trolltech.com>
+ * Copyright (C) 2008 Holger Hans Peter Freyther
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#if USE(QT4_UNICODE)
+#include "TextCodecQt.h"
+
+#include <qset.h>
+#include <wtf/text/CString.h>
+#include <wtf/text/WTFString.h>
+
+namespace WebCore {
+
+static QSet<QByteArray> *unique_names = 0;
+
+static const char *getAtomicName(const QByteArray &name)
+{
+    if (!unique_names)
+        unique_names = new QSet<QByteArray>;
+
+    unique_names->insert(name);
+    return unique_names->find(name)->constData();
+}
+
+void TextCodecQt::registerEncodingNames(EncodingNameRegistrar registrar)
+{
+    QList<int> mibs = QTextCodec::availableMibs();
+
+    for (int i = 0; i < mibs.size(); ++i) {
+        QTextCodec *c = QTextCodec::codecForMib(mibs.at(i));
+        const char *name = getAtomicName(c->name());
+        registrar(name, name);
+        QList<QByteArray> aliases = c->aliases();
+        for (int i = 0; i < aliases.size(); ++i) {
+            const char *a = getAtomicName(aliases.at(i));
+            registrar(a, name);
+        }
+    }
+}
+
+static PassOwnPtr<TextCodec> newTextCodecQt(const TextEncoding& encoding, const void*)
+{
+    return adoptPtr(new TextCodecQt(encoding));
+}
+
+void TextCodecQt::registerCodecs(TextCodecRegistrar registrar)
+{
+    QList<int> mibs = QTextCodec::availableMibs();
+
+    for (int i = 0; i < mibs.size(); ++i) {
+        QTextCodec *c = QTextCodec::codecForMib(mibs.at(i));
+        const char *name = getAtomicName(c->name());
+        registrar(name, newTextCodecQt, 0);
+    }
+}
+
+TextCodecQt::TextCodecQt(const TextEncoding& encoding)
+    : m_encoding(encoding)
+{
+    m_codec = QTextCodec::codecForName(m_encoding.name());
+}
+
+TextCodecQt::~TextCodecQt()
+{
+}
+
+
+String TextCodecQt::decode(const char* bytes, size_t length, bool flush, bool /*stopOnError*/, bool& sawError)
+{
+    // We chop input buffer to smaller buffers to avoid excessive memory consumption
+    // when the input buffer is big.  This helps reduce peak memory consumption in
+    // mobile devices where system RAM is limited.
+    static const int MaxInputChunkSize = 1024 * 1024;
+    const char* buf = bytes;
+    const char* end = buf + length;
+    String unicode(""); // a non-null string is expected
+
+    while (buf < end) {
+        int size = end - buf;
+        size = qMin(size, MaxInputChunkSize);
+        QString decoded = m_codec->toUnicode(buf, size, &m_state);
+        unicode.append(reinterpret_cast_ptr<const UChar*>(decoded.unicode()), decoded.length());
+        buf += size;
+    }
+
+    sawError = m_state.invalidChars != 0;
+
+    if (flush) {
+        m_state.flags = QTextCodec::DefaultConversion;
+        m_state.remainingChars = 0;
+        m_state.invalidChars = 0;
+    }
+
+    return unicode;
+}
+
+CString TextCodecQt::encode(const UChar* characters, size_t length, UnencodableHandling handling)
+{
+    QTextCodec::ConverterState state;
+    state.flags = QTextCodec::ConversionFlags(QTextCodec::ConvertInvalidToNull | QTextCodec::IgnoreHeader);
+
+    if (!length)
+        return "";
+
+    QByteArray ba = m_codec->fromUnicode(reinterpret_cast<const QChar*>(characters), length, &state);
+
+    // If some <b> characters </b> are unencodable, escape them as specified by <b> handling </b>
+    // We append one valid encoded chunk to a QByteArray at a time. When we encounter an unencodable chunk we
+    // escape it with getUnencodableReplacement, append it, then move to the next chunk.
+    if (state.invalidChars) {
+        state.invalidChars = 0;
+        state.remainingChars = 0;
+        int len = 0;
+        ba.clear();
+        for (size_t pos = 0; pos < length; ++pos) {
+            QByteArray tba = m_codec->fromUnicode(reinterpret_cast<const QChar*>(characters), ++len, &state);
+            if (state.remainingChars)
+                continue;
+            if (state.invalidChars) {
+                UnencodableReplacementArray replacement;
+                getUnencodableReplacement(characters[0], handling, replacement);
+                tba.replace('\0', replacement);
+                state.invalidChars = 0;
+            }
+            ba.append(tba);
+            characters += len;
+            len = 0;
+            state.remainingChars = 0;
+        }
+    }
+
+    return CString(ba.constData(), ba.length());
+}
+
+
+} // namespace WebCore
+#endif
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/qt/TextCodecQt.h	1969-12-31 18:00:00.000000000 -0600
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/platform/text/qt/TextCodecQt.h	2015-07-13 16:55:21.371547600 -0500
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2006 Lars Knoll <lars@trolltech.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef TextCodecQt_h
+#define TextCodecQt_h
+
+#include "TextCodec.h"
+#include "TextEncoding.h"
+#include <QTextCodec>
+
+namespace WebCore {
+
+    class TextCodecQt : public TextCodec {
+    public:
+        static void registerEncodingNames(EncodingNameRegistrar);
+        static void registerCodecs(TextCodecRegistrar);
+
+        TextCodecQt(const TextEncoding&);
+        virtual ~TextCodecQt();
+
+        virtual String decode(const char*, size_t length, bool flush, bool stopOnError, bool& sawError);
+        virtual CString encode(const UChar*, size_t length, UnencodableHandling);
+
+    private:
+        TextEncoding m_encoding;
+        QTextCodec *m_codec;
+        QTextCodec::ConverterState m_state;
+    };
+
+} // namespace WebCore
+
+#endif // TextCodecICU_h
--- origsrc/qtwebkit-opensource-src-5.4.2/Source/WebCore/rendering/RenderText.cpp	2015-05-29 15:30:59.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Source/WebCore/rendering/RenderText.cpp	2015-07-13 16:55:29.963638700 -0500
@@ -100,7 +100,7 @@ static void makeCapitalized(String* stri
         return;
 
     unsigned length = string->length();
-    const StringImpl& stringImpl = *string->impl();
+    const UChar* characters = string->characters();
 
     if (length >= numeric_limits<unsigned>::max())
         CRASH();
@@ -109,29 +109,28 @@ static void makeCapitalized(String* stri
     stringWithPrevious[0] = previous == noBreakSpace ? ' ' : previous;
     for (unsigned i = 1; i < length + 1; i++) {
         // Replace &nbsp with a real space since ICU no longer treats &nbsp as a word separator.
-        if (stringImpl[i - 1] == noBreakSpace)
+        if (characters[i - 1] == noBreakSpace)
             stringWithPrevious[i] = ' ';
         else
-            stringWithPrevious[i] = stringImpl[i - 1];
+            stringWithPrevious[i] = characters[i - 1];
     }
 
     TextBreakIterator* boundary = wordBreakIterator(stringWithPrevious.characters(), length + 1);
     if (!boundary)
         return;
 
-    StringBuilder result;
-    result.reserveCapacity(length);
+    StringBuffer<UChar> data(length);
 
     int32_t endOfWord;
     int32_t startOfWord = textBreakFirst(boundary);
     for (endOfWord = textBreakNext(boundary); endOfWord != TextBreakDone; startOfWord = endOfWord, endOfWord = textBreakNext(boundary)) {
         if (startOfWord) // Ignore first char of previous string
-            result.append(stringImpl[startOfWord - 1] == noBreakSpace ? noBreakSpace : toTitleCase(stringWithPrevious[startOfWord]));
+            data[startOfWord - 1] = characters[startOfWord - 1] == noBreakSpace ? noBreakSpace : toTitleCase(stringWithPrevious[startOfWord]);
         for (int i = startOfWord + 1; i < endOfWord; i++)
-            result.append(stringImpl[i - 1]);
+            data[i - 1] = characters[i - 1];
     }
 
-    *string = result.toString();
+    *string = String::adopt(data);
 }
 
 RenderText::RenderText(Node* node, PassRefPtr<StringImpl> str)
--- origsrc/qtwebkit-opensource-src-5.4.2/Tools/qmake/mkspecs/features/configure.prf	2015-05-29 15:30:55.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Tools/qmake/mkspecs/features/configure.prf	2015-07-13 16:55:10.556174200 -0500
@@ -115,9 +115,9 @@ defineTest(finalizeConfigure) {
     }
 
     # Sanity checks that would prevent us from building the whole project altogether.
-    !android:!mac:!config_icu {
-       addReasonForSkippingBuild("ICU is required.")
-    }
+#    !android:!mac:!config_icu {
+#       addReasonForSkippingBuild("ICU is required.")
+#    }
     production_build:blackberry|qnx {
         addReasonForSkippingBuild("Build not supported on BB10/QNX yet.")
     }
--- origsrc/qtwebkit-opensource-src-5.4.2/Tools/qmake/mkspecs/features/features.prf	2015-05-29 15:30:55.000000000 -0500
+++ src/qtwebkit-opensource-src-5.4.2/Tools/qmake/mkspecs/features/features.prf	2015-07-13 16:55:10.638684700 -0500
@@ -142,7 +142,7 @@ defineTest(detectFeatures) {
     # IndexedDB requires leveldb
     enable?(indexed_database): WEBKIT_CONFIG += use_leveldb
 
-    !config_icu:!mac: WEBKIT_CONFIG += use_wchar_unicode
+#    !config_icu:!mac: WEBKIT_CONFIG += use_wchar_unicode
 
     export(WEBKIT_CONFIG)
     export(CONFIGURE_WARNINGS)
